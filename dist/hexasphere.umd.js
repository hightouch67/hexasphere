(function(j,z){typeof exports=="object"&&typeof module<"u"?z(exports,require("three")):typeof define=="function"&&define.amd?define(["exports","three"],z):(j=typeof globalThis<"u"?globalThis:j||self,z(j.Hexasphere={},j.THREE))})(this,function(j,z){"use strict";function F(C){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(C){for(const t in C)if(t!=="default"){const n=Object.getOwnPropertyDescriptor(C,t);Object.defineProperty(e,t,n.get?n:{enumerable:!0,get:()=>C[t]})}}return e.default=C,Object.freeze(e)}const f=F(z);class w{constructor(e=0,t=0,n=0){this.faces=[],this.x=parseFloat(e.toFixed(3)),this.y=parseFloat(t.toFixed(3)),this.z=parseFloat(n.toFixed(3))}subdivide(e,t,n){const i=[];i.push(this);for(let o=1;o<t;o++){const s=new w(this.x*(1-o/t)+e.x*(o/t),this.y*(1-o/t)+e.y*(o/t),this.z*(1-o/t)+e.z*(o/t));i.push(n(s))}return i.push(e),i}segment(e,t){t=Math.max(.01,Math.min(1,t));const n=e.x*(1-t)+this.x*t,i=e.y*(1-t)+this.y*t,o=e.z*(1-t)+this.z*t;return new w(n,i,o)}project(e){const t=Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2)+Math.pow(this.z,2)),n=e/t;return this.x=this.x*n,this.y=this.y*n,this.z=this.z*n,this}registerFace(e){this.faces.find(t=>t.id===e.id)||this.faces.push(e)}getOrderedFaces(){const e=this.faces.slice(),t=[];let n=0;for(;n<this.faces.length&&e.length>0;){if(n===0)t.push(e[0]),e.splice(0,1);else{let i=!1;for(let o=0;o<e.length;o++)if(e[o].isAdjacentTo(t[n-1])){t.push(e[o]),e.splice(o,1),i=!0;break}if(!i)break}n++}return t}toString(){return`${this.x},${this.y},${this.z}`}}const T=class T{constructor(e,t,n,i=!0){this.id=T.idCounter++,this.points=[e,t,n],i&&(e.registerFace(this),t.registerFace(this),n.registerFace(this))}getOtherPoints(e){return this.points.filter(t=>t.toString()!==e.toString())}isAdjacentTo(e){if(!(e!=null&&e.points))return!1;let t=0;for(const n of this.points)for(const i of e.points)n.toString()===i.toString()&&t++;return t===2}getCentroid(){if(this.centroid)return this.centroid;const e=(this.points[0].x+this.points[1].x+this.points[2].x)/3,t=(this.points[0].y+this.points[1].y+this.points[2].y)/3,n=(this.points[0].z+this.points[1].z+this.points[2].z)/3;return this.centroid=new w(e,t,n),this.centroid}};T.idCounter=0;let g=T;class I{constructor(e,t=1){this.neighbors=[],t=Math.max(.01,Math.min(1,t)),this.centerPoint=e,this.faces=e.getOrderedFaces(),this.boundary=[],this.neighborIds=[];const n={};for(let i=0;i<this.faces.length;i++){this.boundary.push(this.faces[i].getCentroid().segment(this.centerPoint,t));const o=this.faces[i].getOtherPoints(this.centerPoint);for(let s=0;s<Math.min(2,o.length);s++)n[o[s].toString()]=1}if(this.neighborIds=Object.keys(n),this.boundary.length>=4){const i={x:this.boundary[2].x-this.boundary[1].x,y:this.boundary[2].y-this.boundary[1].y,z:this.boundary[2].z-this.boundary[1].z},o={x:this.boundary[3].x-this.boundary[1].x,y:this.boundary[3].y-this.boundary[1].y,z:this.boundary[3].z-this.boundary[1].z},s={x:i.y*o.z-i.z*o.y,y:i.z*o.x-i.x*o.z,z:i.x*o.y-i.y*o.x};this.centerPoint.x*s.x+this.centerPoint.y*s.y+this.centerPoint.z*s.z<0&&this.boundary.reverse()}}getLatLon(e){const t=Math.acos(this.centerPoint.y/e),n=(Math.atan2(this.centerPoint.x,this.centerPoint.z)+Math.PI+Math.PI/2)%(Math.PI*2)-Math.PI;return{lat:180*t/Math.PI-90,lon:180*n/Math.PI}}toString(){return this.centerPoint.toString()}}class D{constructor(e,t,n,i,o){this.tiles=[],this.tileLookup={},this.pathLines=[],this.tileLabels=[],this.radius=e,this.scene=i,this.viewMode=o,this.loadProjectionMap().then(()=>{this.generateHexasphere(e,t,n,this.viewMode)})}async loadProjectionMap(){return new Promise(e=>{const t=document.getElementById("projection");if(!t){e();return}const n=()=>{this.projectionCanvas=document.createElement("canvas");const i=this.projectionCanvas.getContext("2d");this.projectionCanvas.width=t.naturalWidth||t.width,this.projectionCanvas.height=t.naturalHeight||t.height,i.drawImage(t,0,0),this.projectionData=i.getImageData(0,0,this.projectionCanvas.width,this.projectionCanvas.height)};t.complete&&t.naturalWidth>0?n():t.onload=n,e()})}generateHexasphere(e,t,n,i){const o=1.61803399,s=[new w(1e3,o*1e3,0),new w(-1e3,o*1e3,0),new w(1e3,-o*1e3,0),new w(-1e3,-o*1e3,0),new w(0,1e3,o*1e3),new w(0,-1e3,o*1e3),new w(0,1e3,-o*1e3),new w(0,-1e3,-o*1e3),new w(o*1e3,0,1e3),new w(-o*1e3,0,1e3),new w(o*1e3,0,-1e3),new w(-o*1e3,0,-1e3)],a={};for(const c of s)a[c.toString()]=c;const l=[new g(s[0],s[1],s[4],!1),new g(s[1],s[9],s[4],!1),new g(s[4],s[9],s[5],!1),new g(s[5],s[9],s[3],!1),new g(s[2],s[3],s[7],!1),new g(s[3],s[2],s[5],!1),new g(s[7],s[10],s[2],!1),new g(s[0],s[8],s[10],!1),new g(s[0],s[4],s[8],!1),new g(s[8],s[2],s[10],!1),new g(s[8],s[4],s[5],!1),new g(s[8],s[5],s[2],!1),new g(s[1],s[0],s[6],!1),new g(s[11],s[1],s[6],!1),new g(s[3],s[9],s[11],!1),new g(s[6],s[10],s[7],!1),new g(s[3],s[11],s[7],!1),new g(s[11],s[6],s[7],!1),new g(s[6],s[0],s[10],!1),new g(s[9],s[1],s[11],!1)],u=c=>{const h=c.toString();return a[h]?a[h]:(a[h]=c,c)};let d=[];for(let c=0;c<l.length;c++){let h=[];const r=[l[c].points[0]],m=l[c].points[0].subdivide(l[c].points[1],t,u),b=l[c].points[0].subdivide(l[c].points[2],t,u);for(let y=1;y<=t;y++){h=r.slice(),r.length=0,r.push(...m[y].subdivide(b[y],y,u));for(let M=0;M<y;M++)d.push(new g(h[M],r[M],r[M+1])),M>0&&d.push(new g(h[M-1],h[M],r[M]))}}const p={};for(const c in a){const h=a[c].project(e);p[h.toString()]=h}this.tiles=[],this.tileLookup={};for(const c in p){const h=new I(p[c],n);this.tiles.push(h),this.tileLookup[p[c].toString()]=h}for(const c of this.tiles)for(const h of c.neighborIds){const r=this.tileLookup[h];r&&r!==c&&c.neighbors.push(r)}console.log(`ðŸ”— Neighbor resolution complete. Tiles: ${this.tiles.length}`);const x=this.tiles.filter(c=>c.neighbors.length>0).length;if(console.log(`ðŸ”— Tiles with neighbors: ${x}/${this.tiles.length}`),this.tiles.length>0){const c=this.tiles.reduce((h,r)=>h+r.neighbors.length,0)/this.tiles.length;console.log(`ðŸ”— Average neighbors per tile: ${c.toFixed(1)}`)}console.log(this.viewMode),(this.viewMode==="tile"||this.viewMode==="both")&&this.createMeshes(),(this.viewMode==="planet"||this.viewMode==="both")&&this.createPlanetMesh()}isLand(e,t){if(!this.projectionData||!this.projectionCanvas)return Math.random()>.3;const n=Math.floor(this.projectionCanvas.width*(t+180)/360),i=Math.floor(this.projectionCanvas.height*(e+90)/180),o=Math.max(0,Math.min(this.projectionCanvas.width-1,n)),a=(Math.max(0,Math.min(this.projectionCanvas.height-1,i))*this.projectionCanvas.width+o)*4;return this.projectionData.data[a]===0}isLandPublic(e,t){return this.isLand(e,t)}getBasicTerrainType(e,t){if(!this.projectionData||!this.projectionCanvas)return"ocean";const n=Math.floor(this.projectionCanvas.width*(t+180)/360),i=Math.floor(this.projectionCanvas.height*(e+90)/180),o=Math.max(0,Math.min(this.projectionCanvas.width-1,n)),a=(Math.max(0,Math.min(this.projectionCanvas.height-1,i))*this.projectionCanvas.width+o)*4,l=this.projectionData.data[a],u=this.projectionData.data[a+2];if(!(l===0))return"ocean";const p=u;return p===255?"arctic":p===50?"desert":p===100?"mountain":p===180?"forest":p===200?"city":"forest"}getMountainDensity(e,t,n=5){let i=0,o=0;for(let s=-n;s<=n;s+=2)for(let a=-n;a<=n;a+=2){const l=e+s,u=t+a;l>=-90&&l<=90&&u>=-180&&u<=180&&(this.getBasicTerrainType(l,u)==="mountain"&&i++,o++)}return o>0?i/o:0}getTerrainInfo(e,t){if(!this.projectionData||!this.projectionCanvas)return{type:"ocean",elevation:0,temperature:15,color:992066};const n=Math.floor(this.projectionCanvas.width*(t+180)/360),i=Math.floor(this.projectionCanvas.height*(e+90)/180),o=Math.max(0,Math.min(this.projectionCanvas.width-1,n)),a=(Math.max(0,Math.min(this.projectionCanvas.height-1,i))*this.projectionCanvas.width+o)*4,l=this.projectionData.data[a],u=this.projectionData.data[a+1],d=this.projectionData.data[a+2];if(!(l===0)){const m=Math.min(255-d,200),b=[992066,1981066,2450411,3900150];return{type:"ocean",elevation:-m,temperature:Math.max(0,25-Math.abs(e)*.3),color:b[Math.min(3,Math.floor(m/50))]}}const c=35-Math.abs(e)*.7,h=u,r=d;if(r===255)return{type:"arctic",elevation:h,temperature:Math.min(c,-5),color:16317180};if(r===240)return{type:"arctic",elevation:h,temperature:Math.min(c,0),color:14412542};if(r===50){const m=[16498468,16096779,14251782,11817737];return{type:"desert",elevation:h,temperature:Math.max(c,25),color:m[Math.min(3,Math.floor(h/64))]}}else if(r===100){const m=[7893356,5722958,4472892,2696484],b=this.getMountainDensity(e,t,3),y=h,M=.3+b*.7,v=y*M,L=.9+Math.random()*.2,P=Math.floor(v*L);return Math.random()<.005&&console.log(`Mountain at lat:${e.toFixed(1)}, lon:${t.toFixed(1)} - density:${b.toFixed(2)}, base:${y}, final:${P}`),{type:"mountain",elevation:P,temperature:c-P*.1,color:m[Math.min(3,Math.floor(P/64))]}}else return r===180?{type:"forest",elevation:h,temperature:c,color:[1467700,1409085,1483594,2278750][Math.min(3,Math.floor(h/64))]}:r===200?{type:"city",elevation:h,temperature:c+5,color:16711935}:{type:"forest",elevation:h,temperature:c,color:[8190976,3767554,7859712,6402857,8647980][Math.min(4,Math.floor(h/51))]}}findPath(e,t){const n=[e],i=new Set,o=new Map,s=new Map,a=new Map;for(const l of this.tiles)s.set(l,1/0),a.set(l,1/0);for(s.set(e,0),a.set(e,this.heuristic(e,t));n.length>0;){let l=n[0];for(const u of n)a.get(u)<a.get(l)&&(l=u);if(l===t){const u=[];let d=l;for(;d;)u.unshift(d),d=o.get(d);return u}n.splice(n.indexOf(l),1),i.add(l);for(const u of l.neighbors){if(i.has(u))continue;const d=s.get(l)+1;if(!n.includes(u))n.push(u);else if(d>=s.get(u))continue;o.set(u,l),s.set(u,d),a.set(u,d+this.heuristic(u,t))}}return[]}heuristic(e,t){const n=e.centerPoint.x-t.centerPoint.x,i=e.centerPoint.y-t.centerPoint.y,o=e.centerPoint.z-t.centerPoint.z;return Math.sqrt(n*n+i*i+o*o)}addTileLabel(e,t,n=16777215,i=5){if(!this.tiles[e])return new f.Object3D;this.tileLabelCounts||(this.tileLabelCounts=new Map);const s=this.tileLabelCounts.get(e)||0;this.tileLabelCounts.set(e,s+1);const a=document.createElement("canvas"),l=a.getContext("2d");a.width=256,a.height=64,l.fillStyle=`#${n.toString(16).padStart(6,"0")}`,l.font="Bold 24px Arial",l.textAlign="center",l.fillText(t,128,40);const u=new f.CanvasTexture(a),d=new f.SpriteMaterial({map:u}),p=new f.Sprite(d),x=s*2,c=this.getTilePosition(e,i+x);p.position.copy(c),p.scale.set(8,2,1);const h=new f.BufferGeometry,r=this.getTilePosition(e,.5);h.setFromPoints([r,c]);const m=new f.LineBasicMaterial({color:n,transparent:!0,opacity:.7}),b=new f.Line(h,m),y=new f.Group;return y.add(p),y.add(b),this.scene.add(y),this.tileLabels.push(y),y}getTilePosition(e,t){const n=this.tiles[e];if(!n)return new f.Vector3;const i=n.centerPoint,o=Math.sqrt(i.x*i.x+i.y*i.y+i.z*i.z);return new f.Vector3(i.x/o,i.y/o,i.z/o).multiplyScalar(this.radius+t)}createCurvedLine(e,t,n=65535,i=20){const o=this.tiles[e],s=this.tiles[t];if(!o||!s)return new f.Mesh;const a=this.getTilePosition(e,.5),l=this.getTilePosition(t,.5),u=a.distanceTo(l),d=Math.min(u*.3,this.radius*.25),p=[];for(let m=0;m<=i;m++){const b=m/i,y=a.clone().normalize().dot(l.clone().normalize()),M=Math.acos(Math.max(-1,Math.min(1,y)));let v;if(M<.001)v=a.clone().lerp(l,b);else{const S=Math.sin(M),H=Math.sin((1-b)*M)/S,O=Math.sin(b*M)/S;v=a.clone().multiplyScalar(H).add(l.clone().multiplyScalar(O)),v.normalize()}const L=1-Math.pow(2*b-1,2),P=.5+d*L;v.multiplyScalar(this.radius+P),p.push(v)}const x=new f.CatmullRomCurve3(p),c=new f.TubeGeometry(x,i,.08,6,!1),h=new f.MeshBasicMaterial({color:n,transparent:!0,opacity:.9}),r=new f.Mesh(c,h);return this.scene.add(r),this.pathLines.push(r),r}clearPathLines(){for(const e of this.pathLines)this.scene.remove(e),e.geometry.dispose(),e.material.dispose();this.pathLines=[]}clearTileLabels(){for(const e of this.tileLabels)this.scene.remove(e),e.traverse(t=>{t instanceof f.Mesh||t instanceof f.Line?(t.geometry.dispose(),Array.isArray(t.material)?t.material.forEach(n=>n.dispose()):t.material.dispose()):t instanceof f.Sprite&&t.material.dispose()});this.tileLabels=[],this.tileLabelCounts=new Map}createMeshes(){for(const e of this.tiles){if(e.boundary.length<3)continue;const t=e.getLatLon(this.radius),n=this.getTerrainInfo(t.lat,t.lon);let i=0;n.type==="mountain"?i=.08:n.type==="arctic"&&n.elevation>150?i=.06:n.type==="desert"?i=.03:n.type==="forest"?i=.02:n.type==="city"&&(i=.12);const o=new f.BufferGeometry,s=[],a=[];if(i>0){const p=n.elevation/255*i*this.radius,x=[],c=[];for(const r of e.boundary){x.push(r.x,r.y,r.z);const m=Math.sqrt(r.x*r.x+r.y*r.y+r.z*r.z),b=r.x/m,y=r.y/m,M=r.z/m,v=r.x+b*p,L=r.y+y*p,P=r.z+M*p;c.push(v,L,P)}s.push(...x,...c);const h=e.boundary.length;for(let r=1;r<h-1;r++)a.push(h,h+r,h+r+1);h>2&&a.push(h,h+h-1,h+1);for(let r=0;r<h;r++){const m=(r+1)%h;a.push(r,m,h+r),a.push(m,h+m,h+r)}for(let r=1;r<h-1;r++)a.push(0,r+1,r);h>2&&a.push(0,1,h-1)}else{for(const p of e.boundary)s.push(p.x,p.y,p.z);for(let p=1;p<e.boundary.length-1;p++)a.push(0,p,p+1);e.boundary.length>2&&a.push(0,e.boundary.length-1,1)}o.setAttribute("position",new f.Float32BufferAttribute(s,3)),o.setIndex(a),o.computeVertexNormals();const l=n.color,u=new f.MeshLambertMaterial({color:l,transparent:!0,opacity:.9}),d=new f.Mesh(o,u);e.mesh=d,this.scene.add(d)}console.log(`âœ… Created ${this.tiles.length} tiles`)}createPlanetMesh(){const e=new f.SphereGeometry(this.radius,128,128),t=e.attributes.position,n=[];for(let s=0;s<t.count;s++){const a=new f.Vector3(t.getX(s),t.getY(s),t.getZ(s)),l=Math.asin(a.y/this.radius)*180/Math.PI,d=(Math.atan2(a.z,a.x)*180/Math.PI+180)/360,p=(l+90)/180;n.push(d,p)}e.setAttribute("uv",new f.Float32BufferAttribute(n,2));for(let s=0;s<t.count;s++){const a=new f.Vector3(t.getX(s),t.getY(s),t.getZ(s));let l=this.tiles[0],u=a.distanceTo(new f.Vector3(l.centerPoint.x,l.centerPoint.y,l.centerPoint.z));for(const c of this.tiles){const h=a.distanceTo(new f.Vector3(c.centerPoint.x,c.centerPoint.y,c.centerPoint.z));h<u&&(u=h,l=c)}const d=l.getLatLon(this.radius),p=this.getTerrainInfo(d.lat,d.lon);let x=0;p&&p.elevation&&(x=p.elevation/255*this.radius*.08),a.normalize().multiplyScalar(this.radius+x),t.setXYZ(s,a.x,a.y,a.z)}t.needsUpdate=!0,e.computeVertexNormals();let i;this.projectionCanvas&&(i=new f.CanvasTexture(this.projectionCanvas),i.wrapS=f.RepeatWrapping,i.wrapT=f.RepeatWrapping);const o=new f.MeshPhongMaterial({map:i,transparent:!1,flatShading:!1});this.planetMesh=new f.Mesh(e,o),this.scene.add(this.planetMesh),console.log("ðŸŒ Created planet mesh with elevations and texture")}getTiles(){return this.tiles}getPlanetMesh(){return this.planetMesh}setTileColor(e,t){e>=0&&e<this.tiles.length&&this.tiles[e].mesh&&this.tiles[e].mesh.material.color.setHex(t)}regenerate(e,t,n){for(const i of this.tiles)i.mesh&&(this.scene.remove(i.mesh),i.mesh.geometry.dispose(),i.mesh.material.dispose());this.clearPathLines(),this.clearTileLabels(),this.tiles=[],this.tileLookup={},g.idCounter=0,this.radius=e,this.generateHexasphere(e,t,n,this.viewMode)}}j.HexaSphere=D,Object.defineProperty(j,Symbol.toStringTag,{value:"Module"})});
